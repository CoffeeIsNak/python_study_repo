
# 1. 인터페이스

- 어떤 객체/시스템을 어떻게 사용할 수 있는지 알려주는 약속(규약)

- 즉, '이 함수/객체는 이런 식으로 쓰세요!' 라는 설명서 + 문법 세트

- 내가 내부 구현은 몰라도 이 버튼 누르면 점프한다는 약속만 지켜지면, 원하는 기능을 사용할 수 있음. → 인터페이스


# 2. 프로그래밍에서의 인터페이스

- 예시: Python의 리스트

```python
lst = [1, 2, 3]
lst.append(4)
len(lst)
```

- `append()`, `len()`, `[]` 등등은 전부 리스트가 노출하고 있는 인터페이스

- 우리는 리스트의 내부 구현을 몰라도 append, len(), `lst[i]` 등의 인터페이스를 통해 상호작용할 수 있음


# 3. 인터페이스 vs 구현

- 인터페이스: `.append()`, `__iter__()` 같은 외부 사용 가능한 메서드들
- 구현: append가 내부적으로 배열을 어떻게 확장하는지 등 실제 로직

- 인터페이스의 장점
    - 추상화 가능 → 내부 구현은 감추고, 어떻게 쓸지만 드러냄
    - 호환성 유지 → 구현이 달라도 인터페이스만 맞으면 잘 작동
    - 유지보수 쉬움 → 외부는 인터페이스만 보면 됨
    - 협업에 최적 → API 문서는 사실 인터페이스 명세서임


# 4. Python에서의 인터페이스 예

1. Magic Method 기반 인터페이스
    - 아래처럼 구현하면 Python은 아 얘 리스트처럼 쓸 수 있겠네 라고 판단
    - 리스트 인터페이스를 따랐다고 인정 (DuckTyping.md 참고)

```python
class MyList:
    def __getitem__(self, i): ...
    def __len__(self): ...
```


2. 타 언어 스타일 인터페이스 예 (Java 등)
    - 어떤 클래스가 Animal 인터페이스를 구현하면, 반드시 makeSound() 정의해야 함
    - 타입 안전성 확보 + 통일된 사용 방식

```java
interface Animal {
    void makeSound();
}
```



# 5. 요약

- 인터페이스 = 객체가 외부와 어떻게 상호작용할지 약속하는 문법/형식

- API와 비교
    - API: 이 객체/서비스를 이런 식으로 사용하세요에 관한 전체 약속
    - Interface: API 안에서도 사용 가능한 명령어들 + 입출력 형식
    - 즉, API는 더 넓은 개념이고, 인터페이스는 그 핵심 구현 방식

- 예제

```python
class Duck:
    def quack(self):
        print("꽥꽥!")

def make_it_quack(animal):
    animal.quack()  # 인터페이스만 맞으면 된다

duck = Duck()
make_it_quack(duck)
```

- 위는 인터페이스만 같으면 어떤 객체든 받아들인다는, 덕 타이핑(Duck Typing) 원리 => 파이썬에서는 타입보다 인터페이스를 더 중요시함


# 6. API vs. Interface

- 인터페이스 (Interface)
    - 뜻: 객체가 외부에 노출하는 "사용 규약"
    - 목적: "이 객체는 이런 방식으로 쓰세요"
    - 구성 요소: 메서드, 속성 등
    - 범위: 좁음 (보통 클래스/객체 단위)
    - 예시: `__len__()`을 구현 → 리스트처럼 작동


- API (Application Programming Interface)
    - 뜻: 전체 시스템/컴포넌트가 제공하는 인터페이스
    - 목적: "이 프로그램/시스템은 이렇게 쓰세요"
    - 구성 요소: 함수, 클래스, 경로(REST), 응답 형식 등
    - 범위: 넓음 (라이브러리, 웹 서비스 전체 포함)
    - 예시: `pandas.DataFrame`, `GET /users` API









